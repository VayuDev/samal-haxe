@start_hx
import haxe.Int32;
import samal.lang.Datatype;
import haxe.Exception;
using samal.lang.Util.NullTools;
using samal.lang.Datatype.DatatypeHelpers;
@end_hx

class SamalFuncDeclParam {
    -name : String
    -datatype : Datatype
}
class SamalCreateStructParam {
    -fieldName : String
    -value : SamalExpression
}

class SamalSimpleTailCallSelfParam {
    -paramName : String
    -value : SamalExpression
}

class SamalStructDeclField {
    -fieldName : String
    -datatype : Datatype
}


class SamalASTNode extends ASTNode {
    
}

class SamalModule extends SamalASTNode {
    -moduleName : String
    +declarations : Array<SamalDeclaration>
}

class SamalDeclaration extends SamalASTNode {
    +name : IdentifierWithTemplate
    @start_hx
    public function completeWithUserTypeMap(mapper : StringToDatatypeMapper) : Void {
        throw new Exception("Not implemented!");
    }
    public function cloneWithTemplateParams(typeMap : StringToDatatypeMapper, templateParams : Array<Datatype>) : SamalDeclaration {
        var cpy = clone();
        cpy.setName(new IdentifierWithTemplate(mName.getName(), templateParams));
        return cpy;
    }
    public function getDatatype() : Datatype {
        throw new Exception("Not implemented!");
    }
    public function getTemplateParams() : Array<Datatype> {
        return mName.getTemplateParams();
    }
    @end_hx
}

class SamalFunctionDeclaration extends SamalDeclaration {
    -params : Array<SamalFuncDeclParam>
    -returnType : Datatype
    -body : SamalScope
    @start_hx
    public override function completeWithUserTypeMap(mapper : StringToDatatypeMapper) {
        mReturnType = mReturnType.complete(mapper);
        mParams = mParams.map(function(p) {
            return new SamalFuncDeclParam(p.getName(), p.getDatatype().complete(mapper));
        });
    }
    public override function getDatatype() : Datatype {
        return Datatype.Function(mReturnType, mParams.map(function(p) {return p.getDatatype();}));
    }
    @end_hx
}
class SamalDatatypeDeclaration extends SamalDeclaration {
}

class SamalStructDeclaration extends SamalDatatypeDeclaration {
    -fields : Array<SamalStructDeclField>
    @start_hx
    public override function completeWithUserTypeMap(mapper : StringToDatatypeMapper) : Void {
        mFields = mFields.map(function(p) {
            return new SamalStructDeclField(p.getFieldName(), p.getDatatype().complete(mapper));
        });
    }
    public override function getDatatype() : Datatype {
        return Datatype.Struct(mName.getName(), mName.getTemplateParams());
    }
    @end_hx
}

class SamalScope extends SamalASTNode {
    -statements : Array<SamalExpression>
    #datatype : Datatype
}

class SamalExpression extends SamalASTNode {
    #datatype : Datatype
}


class SamalAssignmentExpression extends SamalExpression {
    +identifier : String
    -rhs : SamalExpression
}

@start_hx
enum SamalBinaryExpressionOp {
    Add;
    Sub;
    FunctionChain;
    Less;
    More;
    LessEqual;
    MoreEqual;
}
@end_hx

class SamalBinaryExpression extends SamalExpression {
    -lhs : SamalExpression
    -op : SamalBinaryExpressionOp
    -rhs : SamalExpression
}

class SamalCreateLambdaExpression extends SamalExpression {
    -parameters : Array<SamalFuncDeclParam>
    -returnType : Datatype
    -body : SamalScope
    -capturedVariables : Array<SamalFuncDeclParam>
}

class SamalCreateListExpression extends SamalExpression {
    -children : Array<SamalExpression>
}

class SamalCreateStructExpression extends SamalExpression {
    -structName : IdentifierWithTemplate
    -params : Array<SamalCreateStructParam>
}

class SamalFunctionCallExpression extends SamalExpression {
    -function : SamalExpression
    -params : Array<SamalExpression>
}

class SamalIfExpression extends SamalExpression {
    -condition : SamalExpression
    -mainBody : SamalScope
    -elseIfs : Array<SamalElseIfBranch>
    -else : SamalScope

    @start_hx
    public function getAllBranches() : Array<SamalElseIfBranch> {
        return [new SamalElseIfBranch(mCondition, mMainBody)].concat(mElseIfs);
    }
    @end_hx
}

class SamalElseIfBranch {
    -condition : SamalExpression
    -body : SamalScope
}

class SamalLineExpression extends SamalExpression {

}

class SamalLiteralIntExpression extends SamalExpression {
    -val : Int32
}

class SamalLoadIdentifierExpression extends SamalExpression {
    +identifier : IdentifierWithTemplate
}

class SamalMatchExpression extends SamalExpression {
    -toMatch : SamalExpression
    -rows : Array<SamalMatchRow>
}

class SamalMatchRow extends SamalASTNode {
    -shape : SamalShape
    -body : SamalExpression
}

class SamalScopeExpression extends SamalExpression {
    -scope : SamalScope
}

class SamalSimpleListCreateEmpty extends SamalExpression {

}

class SamalSimpleListGetHead extends SamalExpression {
    -list : SamalExpression
}

class SamalSimpleListGetTail extends SamalExpression {
    -list : SamalExpression
}

class SamalSimpleListIsEmpty extends SamalExpression {
    -list : SamalExpression
}

class SamalSimpleListPrepend extends SamalExpression {
    -value : SamalExpression
    -list : SamalExpression
}

class SamalSimpleIfExpression extends SamalExpression {
    -condition : SamalExpression
    -mainBody : SamalScope
    -elseBody : SamalScope
}

class SamalSimpleTailCallSelf extends SamalLineExpression {
    -parameters : Array<SamalSimpleTailCallSelfParam>
}

class SamalShape extends ASTNode {

}

class SamalShapeEmptyList extends SamalShape {

}

class SamalShapeSplitList extends SamalShape {
    -head : SamalShape
    -tail : SamalShape
}

class SamalShapeVariable extends SamalShape {
    -variableName : String
}

class SamalTailCallSelf extends SamalLineExpression {
    -parameters : Array<SamalExpression>
}

@start_hx
enum SamalUnaryExpressionOp {
    Not;
}
@end_hx

class SamalUnaryExpression extends SamalExpression {
    -op : SamalUnaryExpressionOp
    -expr : SamalExpression
}

class SamalSimpleUnreachable extends SamalExpression {

}